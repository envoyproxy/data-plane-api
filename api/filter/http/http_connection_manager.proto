syntax = "proto3";

package envoy.api.v2.filter.http;

import "api/base.proto";
import "api/protocol.proto";
import "api/rds.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

message Rds {
  // Configuration source specifier for RDS.
  ConfigSource config_source = 1;

  // The name of the route configuration. This name will be passed to the RDS
  // API. This allows an Envoy configuration with multiple HTTP listeners (and
  // associated HTTP connection manager filters) to use different route
  // configurations.
  string route_config_name = 2;
}

// Filter on some integer comparison.
message ComparisonFilter {
  // Comparison operator.
  enum Op {
    EQ = 0;
    GE = 1;
  }
  Op op = 1;

  // Value to compare against.
  RuntimeUInt32 value = 2;
}

// Filters on HTTP response/status code.
message StatusCodeFilter {
  ComparisonFilter comparison = 1;
}

// Filters on total request duration in milliseconds.
message DurationFilter {
  ComparisonFilter comparison = 1;
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
message NotHealthCheckFilter {
}

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
message TraceableFilter {
}

// Filters for random sampling of requests. Sampling pivots on the header
// x-request-id being present. If x-request-id is present, the filter will
// consistently sample across multiple hosts based on the runtime key value and
// the value extracted from x-request-id. If it is missing, the filter will
// randomly sample based on the runtime key value.
message RuntimeFilter {
  // Runtime key to get the percentage of requests to be sampled. This runtime
  // control is specified in the range 0-100 and defaults to 0.
  string runtime_key = 1;
}

// Performs a logical “and” operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
message AndFilter {
  repeated AccessLogFilter filters = 1;
}

// Performs a logical “or” operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
message OrFilter {
  repeated AccessLogFilter filters = 2;
}

message AccessLogFilter {
  oneof filter_specifier {
    StatusCodeFilter status_code_filter = 1;
    DurationFilter duration_filter = 2;
    NotHealthCheckFilter not_health_check_filter = 3;
    TraceableFilter traceable_filter = 4;
    RuntimeFilter runtime_filter = 5;
    AndFilter and_filter = 6;
    OrFilter or_filter = 7;
  }
}

// Custom configuration for an AccessLog that writes log entries directly to a file.
// Configures the built-in "envoy.file_access_log" AccessLog.
message FileAccessLog {
  // A path to a local file to which to write the access log entries.
  string path = 1;

  // [V2-API-DIFF] In addition to the existing format specifiers, the following
  // additional specifiers will be available:
  // %TLS_SNI_HOSTNAME%: SNI from handshake.
  // %TLS_VERSION%: Possible values include: “TLSv1”, “TLSv1.1”,
  //     “TLSv1.2”, “TLSv1.3”.
  // %TLS_CIPHER_SUITE%: Cipher suite negotiated during the TLS handshake. The
  //     value is four hex digits defined by the IANA TLS Cipher Suite Registry,
  //     e.g. “009C” for TLS_RSA_WITH_AES_128_GCM_SHA256.
  // TODO(htuch): Document how envoy.http_connection_manager.access_log values
  // can be accessed in the format specifier.
  string format = 2;
}

message AccessLog {
  // The name of the access log implementation to instantiate. The name must
  // match a statically registered access log.
  string name = 1;

  // Filter which is used to determine if the access log needs to be written.
  AccessLogFilter filter = 2;

  // Custom configuration that depends on the access log being instantiated.
  // See the supported AccessLogs for further documentation.
  google.protobuf.Struct config = 3;
}

message HttpFilter {
  // The name of the filter to instantiate. The name must match a supported
  // filter.
  string name = 1;

  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  google.protobuf.Struct config = 2;

  message DeprecatedV1 {
    string type = 1;
  }
  DeprecatedV1 deprecated_v1 = 3;
}

message HttpConnectionManager {
  enum CodecType {
    // For every new connection, the connection manager will determine which
    // codec to use. This mode supports both ALPN for TLS listeners as well as
    // protocol inference for plaintext listeners. If ALPN data is available, it
    // is preferred, otherwise protocol inference is used. In almost all cases,
    // this is the right option to choose for this setting.
    AUTO = 0;
    // The connection manager will assume that the client is speaking HTTP/1.1.
    HTTP1 = 1;
    // The connection manager will assume that the client is speaking HTTP/2
    // (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
    // Prior knowledge is allowed).
    HTTP2 = 2;
  }
  CodecType codec_type = 1;

  // The human readable prefix to use when emitting statistics for the
  // connection manager. See the statistics documentation for more information.
  string stat_prefix = 2;

  oneof route_specifier {
    // The connection manager’s route table will be dynamically loaded via the
    // RDS API
    Rds rds = 3;
    // The route table for the connection manager is static and is specified in
    // this property.
    RouteConfiguration route_config = 4;
  }

  // A list of individual HTTP filters that make up the filter chain for
  // requests made to the connection manager. Order matters as the filters are
  // processed sequentially as request events happen.
  repeated HttpFilter http_filters = 5;

  // Whether the connection manager manipulates the user-agent and
  // x-envoy-downstream-service-cluster headers. See the linked documentation
  // for more information. Defaults to false.
  google.protobuf.BoolValue add_user_agent = 6;

  message Tracing {
    // Span name will be derived from operation_name.
    enum OperationName {
      INGRESS = 0;
      EGRESS = 1;
    }
    OperationName operation_name = 1;

    // The header name is used to populate the tag name, and the header value is
    // used to populate the tag value. The tag is created if the specified
    // header name is present in the request’s headers.
    repeated string request_headers_for_tags = 2;
  }
  Tracing tracing = 7;

  Http1ProtocolOptions http_protocol_options = 8;
  Http2ProtocolOptions http2_protocol_options = 9;

  // An optional override that the connection manager will write to the server
  // header in responses. If not set, the default is envoy.
  string server_name = 10;

  // The idle timeout for connections managed by the connection manager. The
  // idle timeout is defined as the period in which there are no active
  // requests. If not set, there is no idle timeout. When the idle timeout is
  // reached the connection will be closed. If the connection is an HTTP/2
  // connection a drain sequence will occur prior to closing the connection. See
  // drain_timeout.
  google.protobuf.Duration idle_timeout = 11;

  // The time that Envoy will wait between sending an HTTP/2 “shutdown
  // notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
  // This is used so that Envoy provides a grace period for new streams that
  // race with the final GOAWAY frame. During this grace period, Envoy will
  // continue to accept new streams. After the grace period, a final GOAWAY
  // frame is sent and Envoy will start refusing new streams. Draining occurs
  // both when a connection hits the idle timeout or during general server
  // draining. The default grace period is 5000 milliseconds (5 seconds) if this
  // option is not specified.
  google.protobuf.Duration drain_timeout = 12;

  // Configuration for HTTP access logs emitted by the connection manager.
  repeated AccessLog access_log = 13;

  // If set to true, the connection manager will use the real remote address of
  // the client connection when determining internal versus external origin and
  // manipulating various headers. If set to false or absent, the connection
  // manager will use the x-forwarded-for HTTP header. See the documentation for
  // x-forwarded-for, x-envoy-internal, and x-envoy-external-address for more
  // information.
  // TODO(mattklein123): Clean this up, see also discussion in
  // https://github.com/lyft/envoy/issues/794.
  google.protobuf.BoolValue use_remote_address = 14;

  // Whether the connection manager will generate the x-request-id header if it
  // does not exist. This defaults to true. Generating a random UUID4 is
  // expensive so in high throughput scenarios where this feature is not desired
  // it can be disabled.
  google.protobuf.BoolValue generate_request_id = 15;

  // How to handle the x-forwarded-client-cert (XFCC) HTTP header.
  enum ForwardClientCertDetails {
    // Do not send the XFCC header to the next hop. This is the default value.
    SANITIZE = 0;
    // When the client connection is mTLS (Mutual TLS), forward the XFCC header
    // in the request.
    FORWARD_ONLY = 1;
    // When the client connection is mTLS, append the client certificate
    // information to the request’s XFCC header and forward it.
    APPEND_FORWARD = 2;
    // When the client connection is mTLS, reset the XFCC header with the client
    // certificate information and send it to the next hop.
    SANITIZE_SET = 3;
    // Always forward the XFCC header in the request, regardless of whether the
    // client connection is mTLS.
    ALWAYS_FORWARD_ONLY = 4;
  };
  ForwardClientCertDetails forward_client_cert_details = 16;

  // This field is valid only when forward_client_cert is append_forward or
  // sanitize_set and the client connection is mTLS. It specifies the fields in
  // the client certificate to be forwarded. Note that in the
  // x-forwarded-client-cert header, Hash is always set, and By is always set
  // when the client certificate presents the SAN value.
  message SetCurrentClientCertDetails {
    google.protobuf.BoolValue subject = 1;
    google.protobuf.BoolValue san = 2;
  };
  SetCurrentClientCertDetails set_current_client_cert_details = 17;
}
